/**
 * @file psa_can.c
 *
 * @brief This source file was generated by cantools version 40.2.1 Sat Mar 15 13:32:48 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <string.h>

#include "psa_can.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

//static inline uint8_t pack_left_shift_u32(
//    uint32_t value,
//    uint8_t shift,
//    uint8_t mask)
//{
//    return (uint8_t)((uint8_t)(value << shift) & mask);
//}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

//static inline uint8_t pack_right_shift_u32(
//    uint32_t value,
//    uint8_t shift,
//    uint8_t mask)
//{
//    return (uint8_t)((uint8_t)(value >> shift) & mask);
//}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int psa_can_mcu_status_l1_unpack(
    struct psa_can_mcu_status_l1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ready_state = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->gear = unpack_right_shift_u8(src_p[0], 1u, 0x06u);
    dst_p->motor_speed = unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->motor_speed |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

int psa_can_mcu_status_l1_init(struct psa_can_mcu_status_l1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_mcu_status_l1_t));

    return 0;
}

double psa_can_mcu_status_l1_ready_state_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_mcu_status_l1_ready_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_mcu_status_l1_gear_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_mcu_status_l1_gear_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_mcu_status_l1_motor_speed_decode(uint16_t value)
{
    return ((double)value);
}

bool psa_can_mcu_status_l1_motor_speed_is_in_range(uint16_t value)
{
    return (value <= 32767u);
}

int psa_can_mcu_status_l2_unpack(
    struct psa_can_mcu_status_l2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t mot_tmp;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->mcu_stat_battery_vol = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->mcu_stat_battery_vol |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->mcu_stat_current = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->mcu_stat_current |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->mcu_max_current = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->mcu_max_current |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    mot_tmp = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->mot_tmp = (int8_t)mot_tmp;
    dst_p->mos_tmp = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_mcu_status_l2_init(struct psa_can_mcu_status_l2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_mcu_status_l2_t));

    return 0;
}

double psa_can_mcu_status_l2_mcu_stat_battery_vol_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool psa_can_mcu_status_l2_mcu_stat_battery_vol_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_mcu_status_l2_mcu_stat_current_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool psa_can_mcu_status_l2_mcu_stat_current_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_mcu_status_l2_mcu_max_current_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool psa_can_mcu_status_l2_mcu_max_current_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_mcu_status_l2_mot_tmp_decode(int8_t value)
{
    return ((double)value + -40.0);
}

bool psa_can_mcu_status_l2_mot_tmp_is_in_range(int8_t value)
{
    return (value >= 0);
}

double psa_can_mcu_status_l2_mos_tmp_decode(uint8_t value)
{
    return ((double)value + -40.0);
}

bool psa_can_mcu_status_l2_mos_tmp_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_mcu_status_l3_unpack(
    struct psa_can_mcu_status_l3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->fault_code = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->fault_code |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->fault_code |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->fault_code |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

int psa_can_mcu_status_l3_init(struct psa_can_mcu_status_l3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_mcu_status_l3_t));

    return 0;
}

double psa_can_mcu_status_l3_fault_code_decode(uint32_t value)
{
    return ((double)value);
}

bool psa_can_mcu_status_l3_fault_code_is_in_range(uint32_t value)
{
    return (value <= 65535u);
}

int psa_can_mcu_status_r1_unpack(
    struct psa_can_mcu_status_r1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ready_state = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->gear = unpack_right_shift_u8(src_p[0], 1u, 0x06u);
    dst_p->motor_speed = unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->motor_speed |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

int psa_can_mcu_status_r1_init(struct psa_can_mcu_status_r1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_mcu_status_r1_t));

    return 0;
}

double psa_can_mcu_status_r1_ready_state_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_mcu_status_r1_ready_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_mcu_status_r1_gear_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_mcu_status_r1_gear_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_mcu_status_r1_motor_speed_decode(uint16_t value)
{
    return ((double)value);
}

bool psa_can_mcu_status_r1_motor_speed_is_in_range(uint16_t value)
{
    return (value <= 32767u);
}

int psa_can_mcu_status_r2_unpack(
    struct psa_can_mcu_status_r2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t mot_tmp;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->mcu_stat_battery_vol = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->mcu_stat_battery_vol |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->mcu_stat_current = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->mcu_stat_current |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->mcu_max_current = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->mcu_max_current |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    mot_tmp = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->mot_tmp = (int8_t)mot_tmp;
    dst_p->mos_tmp = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_mcu_status_r2_init(struct psa_can_mcu_status_r2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_mcu_status_r2_t));

    return 0;
}

double psa_can_mcu_status_r2_mcu_stat_battery_vol_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool psa_can_mcu_status_r2_mcu_stat_battery_vol_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_mcu_status_r2_mcu_stat_current_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool psa_can_mcu_status_r2_mcu_stat_current_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_mcu_status_r2_mcu_max_current_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool psa_can_mcu_status_r2_mcu_max_current_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_mcu_status_r2_mot_tmp_decode(int8_t value)
{
    return ((double)value + -40.0);
}

bool psa_can_mcu_status_r2_mot_tmp_is_in_range(int8_t value)
{
    return (value >= 0);
}

double psa_can_mcu_status_r2_mos_tmp_decode(uint8_t value)
{
    return ((double)value + -40.0);
}

bool psa_can_mcu_status_r2_mos_tmp_is_in_range(uint8_t value)
{
    return (value <= 240u);
}

int psa_can_mcu_status_r3_unpack(
    struct psa_can_mcu_status_r3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->fault_code = unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->fault_code |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->fault_code |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->fault_code |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

int psa_can_mcu_status_r3_init(struct psa_can_mcu_status_r3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_mcu_status_r3_t));

    return 0;
}

double psa_can_mcu_status_r3_fault_code_decode(uint32_t value)
{
    return ((double)value);
}

bool psa_can_mcu_status_r3_fault_code_is_in_range(uint32_t value)
{
    return (value <= 65535u);
}

int psa_can_mcu_cmdl_pack(
    uint8_t *dst_p,
    const struct psa_can_mcu_cmdl_t *src_p,
    size_t size)
{
    uint16_t target_torque;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->working_mode, 0u, 0x03u);
    dst_p[0] |= pack_left_shift_u8(src_p->gear_setting, 2u, 0x0cu);
    target_torque = (uint16_t)src_p->target_torque;
    dst_p[2] |= pack_left_shift_u16(target_torque, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(target_torque, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->target_speed, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->target_speed, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->mcu_cmd_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->mcu_cmd_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_mcu_cmdl_init(struct psa_can_mcu_cmdl_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_mcu_cmdl_t));

    return 0;
}

uint8_t psa_can_mcu_cmdl_working_mode_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_mcu_cmdl_working_mode_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_mcu_cmdl_gear_setting_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_mcu_cmdl_gear_setting_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int16_t psa_can_mcu_cmdl_target_torque_encode(double value)
{
    return (int16_t)(value);
}

bool psa_can_mcu_cmdl_target_torque_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t psa_can_mcu_cmdl_target_speed_encode(double value)
{
    return (uint16_t)(value);
}

bool psa_can_mcu_cmdl_target_speed_is_in_range(uint16_t value)
{
    return (value <= 32767u);
}

uint8_t psa_can_mcu_cmdl_mcu_cmd_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_mcu_cmdl_mcu_cmd_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_mcu_cmdl_mcu_cmd_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_mcu_cmdl_mcu_cmd_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_mcu_cmdr_pack(
    uint8_t *dst_p,
    const struct psa_can_mcu_cmdr_t *src_p,
    size_t size)
{
    uint16_t target_torque;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->working_mode, 0u, 0x03u);
    dst_p[0] |= pack_left_shift_u8(src_p->gear_setting, 2u, 0x0cu);
    target_torque = (uint16_t)src_p->target_torque;
    dst_p[2] |= pack_left_shift_u16(target_torque, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(target_torque, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->target_speed, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->target_speed, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->mcu_cmd_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->mcu_cmd_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_mcu_cmdr_init(struct psa_can_mcu_cmdr_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_mcu_cmdr_t));

    return 0;
}

uint8_t psa_can_mcu_cmdr_working_mode_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_mcu_cmdr_working_mode_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_mcu_cmdr_gear_setting_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_mcu_cmdr_gear_setting_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int16_t psa_can_mcu_cmdr_target_torque_encode(double value)
{
    return (int16_t)(value);
}

bool psa_can_mcu_cmdr_target_torque_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t psa_can_mcu_cmdr_target_speed_encode(double value)
{
    return (uint16_t)(value);
}

bool psa_can_mcu_cmdr_target_speed_is_in_range(uint16_t value)
{
    return (value <= 32767u);
}

uint8_t psa_can_mcu_cmdr_mcu_cmd_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_mcu_cmdr_mcu_cmd_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_mcu_cmdr_mcu_cmd_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_mcu_cmdr_mcu_cmd_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_rcu_ctrl_cmd_unpack(
    struct psa_can_rcu_ctrl_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t rcu_ster_per;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->rcu_acc_per = unpack_right_shift_u8(src_p[0], 1u, 0xfeu);
    dst_p->rcu_ctrl_mod_req = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    rcu_ster_per = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->rcu_ster_per = (int8_t)rcu_ster_per;
    dst_p->rcu_gear_mod = unpack_right_shift_u8(src_p[2], 6u, 0xc0u);
    dst_p->rcu_one_clk_dump_ctrl = unpack_right_shift_u8(src_p[2], 4u, 0x30u);
    dst_p->rcu_one_clk_clean_ctrl = unpack_right_shift_u8(src_p[2], 2u, 0x0cu);
    dst_p->rcu_dbs_ctrl = unpack_right_shift_u8(src_p[2], 0u, 0x03u);
    dst_p->rcu_se = unpack_right_shift_u8(src_p[3], 2u, 0x0cu);
    dst_p->rcu_sd = unpack_right_shift_u8(src_p[3], 0u, 0x03u);
    dst_p->rcu_v1 = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->rcu_one_clk_dump_ctrl_v = unpack_right_shift_u8(src_p[5], 5u, 0x20u);
    dst_p->rcu_one_clk_clean_ctrl_v = unpack_right_shift_u8(src_p[5], 4u, 0x10u);
    dst_p->rcu_dbs_ctrl_v = unpack_right_shift_u8(src_p[5], 3u, 0x08u);
    dst_p->rcu_ster_per_v = unpack_right_shift_u8(src_p[5], 2u, 0x04u);
    dst_p->rcu_acc_per_v = unpack_right_shift_u8(src_p[5], 1u, 0x02u);
    dst_p->rcu_ctrl_mod_req_v = unpack_right_shift_u8(src_p[5], 0u, 0x01u);
    dst_p->rolling_counter_0x_a1 = unpack_right_shift_u8(src_p[6], 4u, 0xf0u);
    dst_p->rcu_err_can = unpack_right_shift_u8(src_p[6], 3u, 0x08u);
    dst_p->rcu_err_protect = unpack_right_shift_u8(src_p[6], 2u, 0x04u);
    dst_p->rcu_err_los = unpack_right_shift_u8(src_p[6], 1u, 0x02u);
    dst_p->rcu_err_recv = unpack_right_shift_u8(src_p[6], 0u, 0x01u);
    dst_p->checksum_0x_a1 = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_rcu_ctrl_cmd_init(struct psa_can_rcu_ctrl_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_rcu_ctrl_cmd_t));

    return 0;
}

double psa_can_rcu_ctrl_cmd_rcu_acc_per_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_acc_per_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

double psa_can_rcu_ctrl_cmd_rcu_ctrl_mod_req_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_ctrl_mod_req_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rcu_ster_per_decode(int8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_ster_per_is_in_range(int8_t value)
{
    return ((value >= -100) && (value <= 100));
}

double psa_can_rcu_ctrl_cmd_rcu_gear_mod_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_gear_mod_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_rcu_ctrl_cmd_rcu_one_clk_dump_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_one_clk_dump_ctrl_is_in_range(uint8_t value)
{
    return (value <= 2u);
}

double psa_can_rcu_ctrl_cmd_rcu_one_clk_clean_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_one_clk_clean_ctrl_is_in_range(uint8_t value)
{
    return (value <= 2u);
}

double psa_can_rcu_ctrl_cmd_rcu_dbs_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_dbs_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_rcu_ctrl_cmd_rcu_se_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_se_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_rcu_ctrl_cmd_rcu_sd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_sd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_rcu_ctrl_cmd_rcu_v1_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_v1_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_rcu_ctrl_cmd_rcu_one_clk_dump_ctrl_v_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_one_clk_dump_ctrl_v_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rcu_one_clk_clean_ctrl_v_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_one_clk_clean_ctrl_v_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rcu_dbs_ctrl_v_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_dbs_ctrl_v_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rcu_ster_per_v_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_ster_per_v_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rcu_acc_per_v_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_acc_per_v_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rcu_ctrl_mod_req_v_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_ctrl_mod_req_v_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rolling_counter_0x_a1_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rolling_counter_0x_a1_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_rcu_ctrl_cmd_rcu_err_can_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_err_can_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rcu_err_protect_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_err_protect_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rcu_err_los_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_err_los_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_rcu_err_recv_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_rcu_err_recv_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_rcu_ctrl_cmd_checksum_0x_a1_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_rcu_ctrl_cmd_checksum_0x_a1_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_eps_cmd_pack(
    uint8_t *dst_p,
    const struct psa_can_eps_cmd_t *src_p,
    size_t size)
{
    uint16_t eps_target_angle;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->eps_angle_calibrate, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->eps_ctrl_enable, 0u, 0x01u);
    eps_target_angle = (uint16_t)src_p->eps_target_angle;
    dst_p[1] |= pack_right_shift_u16(eps_target_angle, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(eps_target_angle, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->eps_angle_speed, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->eps_angle_speed, 0u, 0xffu);

    return (8);
}

int psa_can_eps_cmd_init(struct psa_can_eps_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_eps_cmd_t));

    return 0;
}

uint8_t psa_can_eps_cmd_eps_angle_calibrate_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_eps_cmd_eps_angle_calibrate_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_eps_cmd_eps_ctrl_enable_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_eps_cmd_eps_ctrl_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int16_t psa_can_eps_cmd_eps_target_angle_encode(double value)
{
    return (int16_t)(value);
}

bool psa_can_eps_cmd_eps_target_angle_is_in_range(int16_t value)
{
    return ((value >= -560) && (value <= 560));
}

uint16_t psa_can_eps_cmd_eps_angle_speed_encode(double value)
{
    return (uint16_t)(value);
}

bool psa_can_eps_cmd_eps_angle_speed_is_in_range(uint16_t value)
{
    return (value <= 450u);
}

int psa_can_eps_status_unpack(
    struct psa_can_eps_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t eps_str_angle_act;
    uint8_t eps_temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->eps_calibration_status = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->eps_fault = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->eps_work_mode_status = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    eps_str_angle_act = unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    eps_str_angle_act |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->eps_str_angle_act = (int16_t)eps_str_angle_act;
    dst_p->eps_angle_spd = unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->eps_angle_spd |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->eps_iq = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    eps_temperature = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->eps_temperature = (int8_t)eps_temperature;
    dst_p->eps_fault_code = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_eps_status_init(struct psa_can_eps_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_eps_status_t));

    return 0;
}

double psa_can_eps_status_eps_calibration_status_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_eps_status_eps_calibration_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_eps_status_eps_fault_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_eps_status_eps_fault_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_eps_status_eps_work_mode_status_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_eps_status_eps_work_mode_status_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_eps_status_eps_str_angle_act_decode(int16_t value)
{
    return ((double)value);
}

bool psa_can_eps_status_eps_str_angle_act_is_in_range(int16_t value)
{
    return ((value >= -720) && (value <= 720));
}

double psa_can_eps_status_eps_angle_spd_decode(uint16_t value)
{
    return ((double)value);
}

bool psa_can_eps_status_eps_angle_spd_is_in_range(uint16_t value)
{
    return (value <= 450u);
}

double psa_can_eps_status_eps_iq_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_eps_status_eps_iq_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_eps_status_eps_temperature_decode(int8_t value)
{
    return ((double)value);
}

bool psa_can_eps_status_eps_temperature_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

double psa_can_eps_status_eps_fault_code_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_eps_status_eps_fault_code_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_bms_fault_unpack(
    struct psa_can_bms_fault_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->bms_fault_insu_res = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->bms_fault_tem_high_f = unpack_right_shift_u8(src_p[1], 6u, 0xc0u);
    dst_p->bms_fault_tem_low_f = unpack_right_shift_u8(src_p[1], 4u, 0x30u);
    dst_p->bms_fault_tem_dev_big_f = unpack_right_shift_u8(src_p[1], 2u, 0x0cu);
    dst_p->bms_fault_cv_high_f = unpack_right_shift_u8(src_p[1], 0u, 0x03u);
    dst_p->bms_fault_cv_low_f = unpack_right_shift_u8(src_p[2], 6u, 0xc0u);
    dst_p->bms_fault_cv_dev_big_f = unpack_right_shift_u8(src_p[2], 4u, 0x30u);
    dst_p->bms_fault_cha_curr_big_f = unpack_right_shift_u8(src_p[2], 2u, 0x0cu);
    dst_p->bms_fault_dis_curr_big_f = unpack_right_shift_u8(src_p[2], 0u, 0x03u);
    dst_p->bms_fault_insu_fade_f = unpack_right_shift_u8(src_p[3], 6u, 0xc0u);
    dst_p->bms_fault_cha_pow_over_lim_f = unpack_right_shift_u8(src_p[3], 4u, 0x30u);
    dst_p->bms_fault_dis_pow_over_lim_f = unpack_right_shift_u8(src_p[3], 2u, 0x0cu);
    dst_p->bms_fault_soc_low_f = unpack_right_shift_u8(src_p[3], 0u, 0x03u);
    dst_p->bms_fault_contactor_adhesion = unpack_right_shift_u8(src_p[4], 6u, 0xc0u);
    dst_p->bms_fault_contactor_invalid = unpack_right_shift_u8(src_p[4], 4u, 0x30u);
    dst_p->bms_fault_precha_fail_f = unpack_right_shift_u8(src_p[4], 2u, 0x0cu);
    dst_p->bms_fault_inter_com_err_f = unpack_right_shift_u8(src_p[4], 0u, 0x03u);
    dst_p->bms_fault_exter_com_err_f = unpack_right_shift_u8(src_p[5], 6u, 0xc0u);
    dst_p->bms_fault_dis_sys_vol_low_f = unpack_right_shift_u8(src_p[5], 4u, 0x30u);
    dst_p->bms_fault_cha_sys_vol_low_f = unpack_right_shift_u8(src_p[5], 2u, 0x0cu);
    dst_p->bms_fault_err_level_f = unpack_right_shift_u8(src_p[5], 0u, 0x03u);
    dst_p->bms_fault_charge_utf = unpack_right_shift_u8(src_p[6], 6u, 0xc0u);
    dst_p->bms_fault_wire_f = unpack_right_shift_u8(src_p[6], 4u, 0x30u);
    dst_p->bms_fault_temp_sensor_f = unpack_right_shift_u8(src_p[6], 2u, 0x0cu);
    dst_p->bms_fault_soh_low_f = unpack_right_shift_u8(src_p[6], 0u, 0x03u);
    dst_p->bms_fault_internal_fan_f = unpack_right_shift_u8(src_p[7], 6u, 0xc0u);
    dst_p->bms_fault_heating_module_f = unpack_right_shift_u8(src_p[7], 4u, 0x30u);
    dst_p->bms_fault_charger_status = unpack_right_shift_u8(src_p[7], 2u, 0x0cu);
    dst_p->bms_fault_hall_zero_ref_f = unpack_right_shift_u8(src_p[7], 0u, 0x03u);

    return (0);
}

int psa_can_bms_fault_init(struct psa_can_bms_fault_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_bms_fault_t));

    return 0;
}

double psa_can_bms_fault_bms_fault_insu_res_decode(uint8_t value)
{
    return ((double)value * 40.0);
}

bool psa_can_bms_fault_bms_fault_insu_res_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_fault_bms_fault_tem_high_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_tem_high_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_tem_low_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_tem_low_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_tem_dev_big_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_tem_dev_big_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_cv_high_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_cv_high_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_cv_low_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_cv_low_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_cv_dev_big_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_cv_dev_big_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_cha_curr_big_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_cha_curr_big_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_dis_curr_big_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_dis_curr_big_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_insu_fade_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_insu_fade_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_cha_pow_over_lim_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_cha_pow_over_lim_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_dis_pow_over_lim_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_dis_pow_over_lim_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_soc_low_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_soc_low_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_contactor_adhesion_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_contactor_adhesion_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_contactor_invalid_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_contactor_invalid_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_precha_fail_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_precha_fail_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_inter_com_err_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_inter_com_err_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_exter_com_err_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_exter_com_err_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_dis_sys_vol_low_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_dis_sys_vol_low_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_cha_sys_vol_low_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_cha_sys_vol_low_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_err_level_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_err_level_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_charge_utf_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_charge_utf_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_wire_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_wire_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_temp_sensor_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_temp_sensor_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_soh_low_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_soh_low_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_internal_fan_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_internal_fan_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_heating_module_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_heating_module_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_charger_status_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_charger_status_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_bms_fault_bms_fault_hall_zero_ref_f_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_fault_bms_fault_hall_zero_ref_f_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int psa_can_bms_status_3_unpack(
    struct psa_can_bms_status_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->bms_status_sys_max_cv_num = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->bms_status_sys_min_cv_num = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->bms_status_sys_sen_max_temp = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->bms_status_sys_sen_max_temp |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->bms_status_sys_sen_min_temp = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->bms_status_sys_sen_min_temp |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->bms_status_sys_sen_max_t_num = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->bms_status_sys_sen_min_t_num = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_bms_status_3_init(struct psa_can_bms_status_3_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_bms_status_3_t));

    return 0;
}

double psa_can_bms_status_3_bms_status_sys_max_cv_num_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_status_3_bms_status_sys_max_cv_num_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_3_bms_status_sys_min_cv_num_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_status_3_bms_status_sys_min_cv_num_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_3_bms_status_sys_sen_max_temp_decode(uint16_t value)
{
    return (((double)value * 0.1) + -40.0);
}

bool psa_can_bms_status_3_bms_status_sys_sen_max_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_3_bms_status_sys_sen_min_temp_decode(uint16_t value)
{
    return (((double)value * 0.1) + -40.0);
}

bool psa_can_bms_status_3_bms_status_sys_sen_min_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_3_bms_status_sys_sen_max_t_num_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_status_3_bms_status_sys_sen_max_t_num_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_3_bms_status_sys_sen_min_t_num_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_status_3_bms_status_sys_sen_min_t_num_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_bms_status_2_unpack(
    struct psa_can_bms_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->bms_status_sys_max_cv = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->bms_status_sys_max_cv |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->bms_status_sys_min_cv = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->bms_status_sys_min_cv |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->bms_status_sys_ave_cv = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->bms_status_sys_ave_cv |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->bms_status_sys_dev_cv = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->bms_status_sys_dev_cv |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_bms_status_2_init(struct psa_can_bms_status_2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_bms_status_2_t));

    return 0;
}

double psa_can_bms_status_2_bms_status_sys_max_cv_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool psa_can_bms_status_2_bms_status_sys_max_cv_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_2_bms_status_sys_min_cv_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool psa_can_bms_status_2_bms_status_sys_min_cv_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_2_bms_status_sys_ave_cv_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool psa_can_bms_status_2_bms_status_sys_ave_cv_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_2_bms_status_sys_dev_cv_decode(uint16_t value)
{
    return ((double)value * 0.001);
}

bool psa_can_bms_status_2_bms_status_sys_dev_cv_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int psa_can_bms_status_1_unpack(
    struct psa_can_bms_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->bms_status_can_count = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->bms_status_sys_current = unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->bms_status_sys_current |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->bms_status_charge = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->bms_status_sys_soc = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->bms_status_sys_voltage = unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->bms_status_sys_voltage |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->bms_status_bus_voltage = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_bms_status_1_init(struct psa_can_bms_status_1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_bms_status_1_t));

    return 0;
}

double psa_can_bms_status_1_bms_status_can_count_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_status_1_bms_status_can_count_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_1_bms_status_sys_current_decode(uint16_t value)
{
    return (((double)value * 0.1) + -500.0);
}

bool psa_can_bms_status_1_bms_status_sys_current_is_in_range(uint16_t value)
{
    return (value <= 10000u);
}

double psa_can_bms_status_1_bms_status_charge_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_bms_status_1_bms_status_charge_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_1_bms_status_sys_soc_decode(uint8_t value)
{
    return ((double)value * 0.5);
}

bool psa_can_bms_status_1_bms_status_sys_soc_is_in_range(uint8_t value)
{
    return (value <= 200u);
}

double psa_can_bms_status_1_bms_status_sys_voltage_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool psa_can_bms_status_1_bms_status_sys_voltage_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_bms_status_1_bms_status_bus_voltage_decode(uint8_t value)
{
    return ((double)value * 2.0);
}

bool psa_can_bms_status_1_bms_status_bus_voltage_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_pmu_cmd_pack(
    uint8_t *dst_p,
    const struct psa_can_pmu_cmd_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_veh_pwrup_cmd, 6u, 0xc0u);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_adcu_pwrup_cmd, 4u, 0x30u);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_mcu_pwrup_cmd, 2u, 0x0cu);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_led_pwrup_cmd, 0u, 0x03u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_eps_pwrup_cmd, 6u, 0xc0u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_ccu_pwrup_cmd, 4u, 0x30u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_obd_pwrup_cmd, 2u, 0x0cu);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_wfc_pwrup_cmd, 0u, 0x03u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_dchager_pwrup_cmd, 6u, 0xc0u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_park_enable_cmd, 4u, 0x30u);
    dst_p[6] |= pack_left_shift_u8(src_p->cu_pwr_cmd_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->cu_pwr_cmd_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_pmu_cmd_init(struct psa_can_pmu_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_pmu_cmd_t));

    return 0;
}

uint8_t psa_can_pmu_cmd_vcu_veh_pwrup_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_veh_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_vcu_adcu_pwrup_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_adcu_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_vcu_mcu_pwrup_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_mcu_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_vcu_led_pwrup_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_led_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_vcu_eps_pwrup_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_eps_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_vcu_ccu_pwrup_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_ccu_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_vcu_obd_pwrup_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_obd_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_vcu_wfc_pwrup_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_wfc_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_vcu_dchager_pwrup_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_dchager_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_vcu_park_enable_cmd_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_vcu_park_enable_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_pmu_cmd_cu_pwr_cmd_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_cu_pwr_cmd_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_pmu_cmd_cu_pwr_cmd_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_pmu_cmd_cu_pwr_cmd_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_pmu_status_unpack(
    struct psa_can_pmu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->pmu_veh_pwrup_sts = unpack_right_shift_u8(src_p[0], 6u, 0xc0u);
    dst_p->pmu_adcu_pwrup_sts = unpack_right_shift_u8(src_p[0], 4u, 0x30u);
    dst_p->pmu_mcu_pwrup_sts = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);
    dst_p->pmu_led_pwrup_sts = unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->pmu_eps_pwrup_sts = unpack_right_shift_u8(src_p[1], 6u, 0xc0u);
    dst_p->pmu_ccu_pwrup_sts = unpack_right_shift_u8(src_p[1], 4u, 0x30u);
    dst_p->pmu_obd_pwrup_sts = unpack_right_shift_u8(src_p[1], 2u, 0x0cu);
    dst_p->pmu_wfc_pwrup_sts = unpack_right_shift_u8(src_p[1], 0u, 0x03u);
    dst_p->pmu_dchager_pwrup_sts = unpack_right_shift_u8(src_p[2], 6u, 0xc0u);
    dst_p->pmu_park_enable_sts = unpack_right_shift_u8(src_p[2], 4u, 0x30u);
    dst_p->pmu_estop_sts = unpack_right_shift_u8(src_p[2], 3u, 0x08u);
    dst_p->pmu_power_off_req = unpack_right_shift_u8(src_p[2], 1u, 0x06u);
    dst_p->pmu_pwr_status_roll_cnt = unpack_right_shift_u8(src_p[6], 0u, 0x0fu);
    dst_p->pmu_pwr_status_checksum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_pmu_status_init(struct psa_can_pmu_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_pmu_status_t));

    return 0;
}

double psa_can_pmu_status_pmu_veh_pwrup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_veh_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_adcu_pwrup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_adcu_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_mcu_pwrup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_mcu_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_led_pwrup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_led_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_eps_pwrup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_eps_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_ccu_pwrup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_ccu_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_obd_pwrup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_obd_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_wfc_pwrup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_wfc_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_dchager_pwrup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_dchager_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_park_enable_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_park_enable_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_estop_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_estop_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_pmu_status_pmu_power_off_req_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_power_off_req_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_pmu_status_pmu_pwr_status_roll_cnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_pwr_status_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_pmu_status_pmu_pwr_status_checksum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_pmu_status_pmu_pwr_status_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_ccu_cmd_pack(
    uint8_t *dst_p,
    const struct psa_can_ccu_cmd_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->ccu_fender_ctrl, 6u, 0xc0u);
    dst_p[0] |= pack_left_shift_u8(src_p->ccu_water_pump_ctrl, 4u, 0x30u);
    dst_p[0] |= pack_left_shift_u8(src_p->ccu_one_clk_dump_ctrl, 2u, 0x0cu);
    dst_p[0] |= pack_left_shift_u8(src_p->ccu_one_clk_clean_ctrl, 0u, 0x03u);
    dst_p[1] |= pack_left_shift_u8(src_p->ccu_sweeping_ctrl, 6u, 0xc0u);
    dst_p[1] |= pack_left_shift_u8(src_p->ccu_water_add_ctrl, 2u, 0x0cu);
    dst_p[1] |= pack_left_shift_u8(src_p->ccu_vbr_ctrl, 0u, 0x03u);
    dst_p[2] |= pack_left_shift_u8(src_p->ccu_dust_bin_lift_ctrl, 6u, 0xc0u);
    dst_p[2] |= pack_left_shift_u8(src_p->ccu_main_brush_lift_ctrl, 4u, 0x30u);
    dst_p[2] |= pack_left_shift_u8(src_p->ccu_side_brush_extend_ctrl, 2u, 0x0cu);
    dst_p[2] |= pack_left_shift_u8(src_p->ccu_side_brush_lift_ctrl, 0u, 0x03u);
    dst_p[3] |= pack_left_shift_u8(src_p->ccu_side_brush_ctrl, 6u, 0xc0u);
    dst_p[3] |= pack_left_shift_u8(src_p->ccu_main_brush_ctrl, 4u, 0x30u);
    dst_p[3] |= pack_left_shift_u8(src_p->ccu_dust_bin_open_ctrl, 2u, 0x0cu);
    dst_p[3] |= pack_left_shift_u8(src_p->ccu_dust_bin_dump_ctrl, 0u, 0x03u);
    dst_p[4] |= pack_left_shift_u8(src_p->ccu_dust_bin_compress_ctrl, 6u, 0xc0u);
    dst_p[4] |= pack_left_shift_u8(src_p->ccu_vacuum_ctrl, 4u, 0x30u);
    dst_p[4] |= pack_left_shift_u8(src_p->ccu_high_water_pump_ctrl, 2u, 0x0cu);
    dst_p[4] |= pack_left_shift_u8(src_p->ccu_blower_ctrl, 0u, 0x03u);
    dst_p[5] |= pack_left_shift_u8(src_p->ccu_wash_probe_adjust_ctrl, 6u, 0xc0u);
    dst_p[5] |= pack_left_shift_u8(src_p->ccu_high_pump_adjust_ctrl, 4u, 0x30u);
    dst_p[5] |= pack_left_shift_u8(src_p->ccu_wash_valve_ctrl, 2u, 0x0cu);
    dst_p[5] |= pack_left_shift_u8(src_p->ccu_clean_valve_ctrl, 0u, 0x03u);
    dst_p[6] |= pack_left_shift_u8(src_p->ccu_cmd_roll_cnt, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->ccu_cmd_check_sum, 0u, 0xffu);

    return (8);
}

int psa_can_ccu_cmd_init(struct psa_can_ccu_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_ccu_cmd_t));

    return 0;
}

uint8_t psa_can_ccu_cmd_ccu_fender_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_fender_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_water_pump_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_water_pump_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_one_clk_dump_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_one_clk_dump_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_one_clk_clean_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_one_clk_clean_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_sweeping_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_sweeping_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_water_add_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_water_add_ctrl_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_ccu_cmd_ccu_vbr_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_vbr_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_dust_bin_lift_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_dust_bin_lift_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_main_brush_lift_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_main_brush_lift_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_side_brush_extend_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_side_brush_extend_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_side_brush_lift_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_side_brush_lift_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_side_brush_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_side_brush_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_main_brush_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_main_brush_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_dust_bin_open_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_dust_bin_open_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_dust_bin_dump_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_dust_bin_dump_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_dust_bin_compress_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_dust_bin_compress_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_vacuum_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_vacuum_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_high_water_pump_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_high_water_pump_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_blower_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_blower_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_wash_probe_adjust_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_wash_probe_adjust_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_high_pump_adjust_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_high_pump_adjust_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_wash_valve_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_wash_valve_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_clean_valve_ctrl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_clean_valve_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_ccu_cmd_ccu_cmd_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_cmd_roll_cnt_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_ccu_cmd_ccu_cmd_check_sum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_ccu_cmd_ccu_cmd_check_sum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_ccu_status2_unpack(
    struct psa_can_ccu_status2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ccu_dustbin_full_st = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->ccu_remain_water = unpack_right_shift_u8(src_p[0], 0u, 0x7fu);
    dst_p->ccu_main_brush_pos_act = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ccu_side_brush_lift_pos_act = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->ccu_side_brush_extend_pos_act = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->ccu_high_pump_angle_act = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->ccu_wash_probe_adjust_act = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->ccu_status1_roll_cnt = unpack_right_shift_u8(src_p[6], 0u, 0x0fu);
    dst_p->ccu_status1_check_sum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_ccu_status2_init(struct psa_can_ccu_status2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_ccu_status2_t));

    return 0;
}

double psa_can_ccu_status2_ccu_dustbin_full_st_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status2_ccu_dustbin_full_st_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_ccu_status2_ccu_remain_water_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status2_ccu_remain_water_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

double psa_can_ccu_status2_ccu_main_brush_pos_act_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status2_ccu_main_brush_pos_act_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_status2_ccu_side_brush_lift_pos_act_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status2_ccu_side_brush_lift_pos_act_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_status2_ccu_side_brush_extend_pos_act_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status2_ccu_side_brush_extend_pos_act_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_status2_ccu_high_pump_angle_act_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status2_ccu_high_pump_angle_act_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_status2_ccu_wash_probe_adjust_act_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status2_ccu_wash_probe_adjust_act_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_status2_ccu_status1_roll_cnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status2_ccu_status1_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_ccu_status2_ccu_status1_check_sum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status2_ccu_status1_check_sum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_ccu_status_unpack(
    struct psa_can_ccu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ccu_fender_sts = unpack_right_shift_u8(src_p[0], 6u, 0xc0u);
    dst_p->ccu_water_pump_sts = unpack_right_shift_u8(src_p[0], 4u, 0x30u);
    dst_p->ccu_one_clk_dump_sts = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);
    dst_p->ccu_one_clk_clean_sts = unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->ccu_sweeping_sts = unpack_right_shift_u8(src_p[1], 6u, 0xc0u);
    dst_p->ccu_wpt_wakeup_sts = unpack_right_shift_u8(src_p[1], 4u, 0x30u);
    dst_p->ccu_water_add_sts = unpack_right_shift_u8(src_p[1], 2u, 0x0cu);
    dst_p->ccu_vbr_sts = unpack_right_shift_u8(src_p[1], 0u, 0x03u);
    dst_p->ccu_dust_bin_lift_sts = unpack_right_shift_u8(src_p[2], 6u, 0xc0u);
    dst_p->ccu_main_brush_lift_sts = unpack_right_shift_u8(src_p[2], 4u, 0x30u);
    dst_p->ccu_side_brush_extend_sts = unpack_right_shift_u8(src_p[2], 2u, 0x0cu);
    dst_p->ccu_side_brush_lift_sts = unpack_right_shift_u8(src_p[2], 0u, 0x03u);
    dst_p->ccu_side_brush_sts = unpack_right_shift_u8(src_p[3], 6u, 0xc0u);
    dst_p->ccu_main_brush_sts = unpack_right_shift_u8(src_p[3], 4u, 0x30u);
    dst_p->ccu_dust_bin_open_sts = unpack_right_shift_u8(src_p[3], 2u, 0x0cu);
    dst_p->ccu_dust_bin_dump_sts = unpack_right_shift_u8(src_p[3], 0u, 0x03u);
    dst_p->ccu_dust_bin_compress_sts = unpack_right_shift_u8(src_p[4], 6u, 0xc0u);
    dst_p->ccu_vacuum_sts = unpack_right_shift_u8(src_p[4], 4u, 0x30u);
    dst_p->ccu_high_water_pump_sts = unpack_right_shift_u8(src_p[4], 2u, 0x0cu);
    dst_p->ccu_blower_sts = unpack_right_shift_u8(src_p[4], 0u, 0x03u);
    dst_p->ccu_wash_probe_adjust_sts = unpack_right_shift_u8(src_p[5], 6u, 0xc0u);
    dst_p->ccu_high_pump_adjust_sts = unpack_right_shift_u8(src_p[5], 4u, 0x30u);
    dst_p->ccu_wash_vale_sts = unpack_right_shift_u8(src_p[5], 2u, 0x0cu);
    dst_p->ccu_clean_vale_sts = unpack_right_shift_u8(src_p[5], 0u, 0x03u);
    dst_p->ccu_status_roll_cnt = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->ccu_status_check_sum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_ccu_status_init(struct psa_can_ccu_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_ccu_status_t));

    return 0;
}

double psa_can_ccu_status_ccu_fender_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_fender_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_water_pump_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_water_pump_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_one_clk_dump_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_one_clk_dump_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_one_clk_clean_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_one_clk_clean_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_sweeping_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_sweeping_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_wpt_wakeup_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_wpt_wakeup_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_ccu_status_ccu_water_add_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_water_add_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_ccu_status_ccu_vbr_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_vbr_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_dust_bin_lift_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_dust_bin_lift_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_main_brush_lift_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_main_brush_lift_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_side_brush_extend_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_side_brush_extend_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_side_brush_lift_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_side_brush_lift_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_side_brush_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_side_brush_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_main_brush_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_main_brush_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_dust_bin_open_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_dust_bin_open_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_dust_bin_dump_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_dust_bin_dump_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_dust_bin_compress_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_dust_bin_compress_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_vacuum_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_vacuum_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_high_water_pump_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_high_water_pump_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_blower_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_blower_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_wash_probe_adjust_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_wash_probe_adjust_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_high_pump_adjust_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_high_pump_adjust_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_wash_vale_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_wash_vale_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_clean_vale_sts_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_clean_vale_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_ccu_status_ccu_status_roll_cnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_status_roll_cnt_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_status_ccu_status_check_sum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_status_ccu_status_check_sum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_ccu_lift_status_unpack(
    struct psa_can_ccu_lift_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->lift_state = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->lift_err = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->lift_pos = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->lift_pos |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->lift_current = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->lift_current |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->ccu_lift_status_rollcnt = unpack_right_shift_u8(src_p[6], 4u, 0xf0u);
    dst_p->lift_id = unpack_right_shift_u8(src_p[6], 0u, 0x0fu);
    dst_p->ccu_lift_status_check_sum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_ccu_lift_status_init(struct psa_can_ccu_lift_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_ccu_lift_status_t));

    return 0;
}

double psa_can_ccu_lift_status_lift_state_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_lift_status_lift_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_lift_status_lift_err_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_lift_status_lift_err_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_lift_status_lift_pos_decode(uint16_t value)
{
    return ((double)value);
}

bool psa_can_ccu_lift_status_lift_pos_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_lift_status_lift_current_decode(uint16_t value)
{
    return ((double)value);
}

bool psa_can_ccu_lift_status_lift_current_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_ccu_lift_status_ccu_lift_status_rollcnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_lift_status_ccu_lift_status_rollcnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_ccu_lift_status_lift_id_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_lift_status_lift_id_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_ccu_lift_status_ccu_lift_status_check_sum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_ccu_lift_status_ccu_lift_status_check_sum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_adcu_sweep_cmd_unpack(
    struct psa_can_adcu_sweep_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->adcu_fender_ctrl = unpack_right_shift_u8(src_p[0], 6u, 0xc0u);
    dst_p->adcu_water_pump_ctrl = unpack_right_shift_u8(src_p[0], 4u, 0x30u);
    dst_p->adcu_one_clk_dump_ctrl = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);
    dst_p->adcu_one_clk_clean_ctrl = unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->adcu_sweeping_ctrl = unpack_right_shift_u8(src_p[1], 6u, 0xc0u);
    dst_p->adcu_water_add_ctrl = unpack_right_shift_u8(src_p[1], 2u, 0x0cu);
    dst_p->adcu_vbr_ctrl = unpack_right_shift_u8(src_p[1], 0u, 0x03u);
    dst_p->adcu_dust_bin_lift_ctrl = unpack_right_shift_u8(src_p[2], 6u, 0xc0u);
    dst_p->adcu_main_brush_lift_ctrl = unpack_right_shift_u8(src_p[2], 4u, 0x30u);
    dst_p->adcu_side_brush_extend_ctrl = unpack_right_shift_u8(src_p[2], 2u, 0x0cu);
    dst_p->adcu_side_brush_lift_ctrl = unpack_right_shift_u8(src_p[2], 0u, 0x03u);
    dst_p->adcu_side_brush_ctrl = unpack_right_shift_u8(src_p[3], 6u, 0xc0u);
    dst_p->adcu_main_brush_ctrl = unpack_right_shift_u8(src_p[3], 4u, 0x30u);
    dst_p->adcu_dust_bin_open_ctrl = unpack_right_shift_u8(src_p[3], 2u, 0x0cu);
    dst_p->adcu_dust_bin_dump_ctrl = unpack_right_shift_u8(src_p[3], 0u, 0x03u);
    dst_p->adcu_dust_bin_compress_ctrl = unpack_right_shift_u8(src_p[4], 6u, 0xc0u);
    dst_p->adcu_vacuum_ctrl = unpack_right_shift_u8(src_p[4], 4u, 0x30u);
    dst_p->adcu_high_water_pump_ctrl = unpack_right_shift_u8(src_p[4], 2u, 0x0cu);
    dst_p->adcu_blower_ctrl = unpack_right_shift_u8(src_p[4], 0u, 0x03u);
    dst_p->adcu_wash_probe_adjust_ctrl = unpack_right_shift_u8(src_p[5], 6u, 0xc0u);
    dst_p->adcu_high_pump_adjust_ctrl = unpack_right_shift_u8(src_p[5], 4u, 0x30u);
    dst_p->adcu_clean_valve_ctrl = unpack_right_shift_u8(src_p[5], 2u, 0x0cu);
    dst_p->adcu_wash_valve_ctrl = unpack_right_shift_u8(src_p[5], 0u, 0x03u);
    dst_p->adcu_sweeper_roll_cnt = unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->adcu_sweeper_check_sum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_adcu_sweep_cmd_init(struct psa_can_adcu_sweep_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_adcu_sweep_cmd_t));

    return 0;
}

double psa_can_adcu_sweep_cmd_adcu_fender_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_fender_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_water_pump_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_water_pump_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_one_clk_dump_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_one_clk_dump_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_one_clk_clean_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_one_clk_clean_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_sweeping_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_sweeping_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_water_add_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_water_add_ctrl_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_sweep_cmd_adcu_vbr_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_vbr_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_dust_bin_lift_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_dust_bin_lift_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_main_brush_lift_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_main_brush_lift_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_side_brush_extend_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_side_brush_extend_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_side_brush_lift_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_side_brush_lift_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_side_brush_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_side_brush_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_main_brush_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_main_brush_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_dust_bin_open_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_dust_bin_open_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_dust_bin_dump_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_dust_bin_dump_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_dust_bin_compress_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_dust_bin_compress_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_vacuum_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_vacuum_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_high_water_pump_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_high_water_pump_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_blower_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_blower_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_wash_probe_adjust_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_wash_probe_adjust_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_high_pump_adjust_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_high_pump_adjust_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_clean_valve_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_clean_valve_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_wash_valve_ctrl_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_wash_valve_ctrl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_sweep_cmd_adcu_sweeper_roll_cnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_sweeper_roll_cnt_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_sweep_cmd_adcu_sweeper_check_sum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_sweep_cmd_adcu_sweeper_check_sum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_adcu_lamp_cmd_unpack(
    struct psa_can_adcu_lamp_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->adcu_head_lamp_cmd = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    dst_p->adcu_dbl_flash_lamp_cmd = unpack_right_shift_u8(src_p[1], 6u, 0x40u);
    dst_p->adcu_turn_l_lamp_cmd = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->adcu_turn_r_lamp_cmd = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->adcu_back_lamp_cmd = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->adcu_buzzer_cmd = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->adcu_horn_cmd = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->adcu_warning_lamp_cmd = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->adcu_brk_lamp_cmd = unpack_right_shift_u8(src_p[2], 7u, 0x80u);
    dst_p->adcu_fog_lamp_cmd = unpack_right_shift_u8(src_p[2], 6u, 0x40u);
    dst_p->adcu_width_lamp_cmd = unpack_right_shift_u8(src_p[2], 5u, 0x20u);
    dst_p->adcu_wiper_cmd = unpack_right_shift_u8(src_p[2], 4u, 0x10u);
    dst_p->adcu_lamp_cmd_roll_cnt = unpack_right_shift_u8(src_p[6], 0u, 0x0fu);
    dst_p->adcu_lamp_cmd_checksum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_adcu_lamp_cmd_init(struct psa_can_adcu_lamp_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_adcu_lamp_cmd_t));

    return 0;
}

double psa_can_adcu_lamp_cmd_adcu_head_lamp_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_head_lamp_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_dbl_flash_lamp_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_dbl_flash_lamp_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_turn_l_lamp_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_turn_l_lamp_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_turn_r_lamp_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_turn_r_lamp_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_back_lamp_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_back_lamp_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_buzzer_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_buzzer_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_horn_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_horn_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_warning_lamp_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_warning_lamp_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_brk_lamp_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_brk_lamp_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_fog_lamp_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_fog_lamp_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_width_lamp_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_width_lamp_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_wiper_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_wiper_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_lamp_cmd_adcu_lamp_cmd_roll_cnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_lamp_cmd_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_adcu_lamp_cmd_adcu_lamp_cmd_checksum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_lamp_cmd_adcu_lamp_cmd_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_adcu_drive_cmd_unpack(
    struct psa_can_adcu_drive_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->adcu_drving_mode = unpack_right_shift_u8(src_p[0], 5u, 0xe0u);
    dst_p->adcu_drv_ctrl_mode = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);
    dst_p->adcu_drv_tgt_gear = unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->adcu_drv_tgt_pedpos = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->adcu_drv_tgt_veh_spd = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->adcu_drv_tgt_veh_spd |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->adcu_drv_tgt_veh_acc_spd = unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->adcu_drv_veh_spd_limit = unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->adcu_drv_cmd0_roll_cnt = unpack_right_shift_u8(src_p[6], 0u, 0x0fu);
    dst_p->adcu_drv_cmd0_checksum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_adcu_drive_cmd_init(struct psa_can_adcu_drive_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_adcu_drive_cmd_t));

    return 0;
}

double psa_can_adcu_drive_cmd_adcu_drving_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_drive_cmd_adcu_drving_mode_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

double psa_can_adcu_drive_cmd_adcu_drv_ctrl_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_drive_cmd_adcu_drv_ctrl_mode_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_drive_cmd_adcu_drv_tgt_gear_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_drive_cmd_adcu_drv_tgt_gear_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_drive_cmd_adcu_drv_tgt_pedpos_decode(uint8_t value)
{
    return ((double)value + -100.0);
}

bool psa_can_adcu_drive_cmd_adcu_drv_tgt_pedpos_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_drive_cmd_adcu_drv_tgt_veh_spd_decode(uint16_t value)
{
    return (((double)value * 0.01) + -100.0);
}

bool psa_can_adcu_drive_cmd_adcu_drv_tgt_veh_spd_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_drive_cmd_adcu_drv_tgt_veh_acc_spd_decode(uint8_t value)
{
    return (((double)value * 0.1) + -15.0);
}

bool psa_can_adcu_drive_cmd_adcu_drv_tgt_veh_acc_spd_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_drive_cmd_adcu_drv_veh_spd_limit_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool psa_can_adcu_drive_cmd_adcu_drv_veh_spd_limit_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_drive_cmd_adcu_drv_cmd0_roll_cnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_drive_cmd_adcu_drv_cmd0_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_adcu_drive_cmd_adcu_drv_cmd0_checksum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_drive_cmd_adcu_drv_cmd0_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_adcu_steer_cmd_unpack(
    struct psa_can_adcu_steer_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->adcu_str_work_mode = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->adcu_str_tgt_angle = unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->adcu_str_tgt_angle |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->adcu_str_tgt_angle_spd = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->adcu_str_centering = unpack_right_shift_u8(src_p[5], 0u, 0x01u);
    dst_p->adcu_str_cmd_roll_cnt = unpack_right_shift_u8(src_p[6], 0u, 0x0fu);
    dst_p->adcu_str_cmd_checksum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_adcu_steer_cmd_init(struct psa_can_adcu_steer_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_adcu_steer_cmd_t));

    return 0;
}

double psa_can_adcu_steer_cmd_adcu_str_work_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_steer_cmd_adcu_str_work_mode_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_steer_cmd_adcu_str_tgt_angle_decode(uint16_t value)
{
    return (((double)value * 0.005) + -90.0);
}

bool psa_can_adcu_steer_cmd_adcu_str_tgt_angle_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_steer_cmd_adcu_str_tgt_angle_spd_decode(uint8_t value)
{
    return ((double)value * 0.2);
}

bool psa_can_adcu_steer_cmd_adcu_str_tgt_angle_spd_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_steer_cmd_adcu_str_centering_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_steer_cmd_adcu_str_centering_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_steer_cmd_adcu_str_cmd_roll_cnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_steer_cmd_adcu_str_cmd_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_adcu_steer_cmd_adcu_str_cmd_checksum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_steer_cmd_adcu_str_cmd_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_adcu_brake_cmd_unpack(
    struct psa_can_adcu_brake_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->adcu_brk_ctrl_mode = unpack_right_shift_u8(src_p[0], 6u, 0xc0u);
    dst_p->adcu_brk_park_enable = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->adcu_brk_tgt_pedpos = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->adcu_brk_tgt_press = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->adcu_brk_tgt_press |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->adcu_brk_tgt_acc_spd = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->adcu_brk_tgt_acc_spd |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->adcu_brk_cmd_roll_cnt = unpack_right_shift_u8(src_p[6], 0u, 0x0fu);
    dst_p->adcu_brk_cmd_checksum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_adcu_brake_cmd_init(struct psa_can_adcu_brake_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_adcu_brake_cmd_t));

    return 0;
}

double psa_can_adcu_brake_cmd_adcu_brk_ctrl_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_brake_cmd_adcu_brk_ctrl_mode_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_brake_cmd_adcu_brk_park_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_brake_cmd_adcu_brk_park_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_brake_cmd_adcu_brk_tgt_pedpos_decode(uint8_t value)
{
    return ((double)value * 0.4);
}

bool psa_can_adcu_brake_cmd_adcu_brk_tgt_pedpos_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_brake_cmd_adcu_brk_tgt_press_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool psa_can_adcu_brake_cmd_adcu_brk_tgt_press_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_brake_cmd_adcu_brk_tgt_acc_spd_decode(uint16_t value)
{
    return (((double)value * 0.01) + -20.0);
}

bool psa_can_adcu_brake_cmd_adcu_brk_tgt_acc_spd_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

double psa_can_adcu_brake_cmd_adcu_brk_cmd_roll_cnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_brake_cmd_adcu_brk_cmd_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_adcu_brake_cmd_adcu_brk_cmd_checksum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_brake_cmd_adcu_brk_cmd_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_adcu_power_cmd_unpack(
    struct psa_can_adcu_power_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->adcu_veh_pwrup_cmd = unpack_right_shift_u8(src_p[0], 6u, 0xc0u);
    dst_p->adcu_emg_brk_req = unpack_right_shift_u8(src_p[0], 4u, 0x30u);
    dst_p->adcu_soft_emg_brk_req = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);
    dst_p->adcu_rmt_pwr_on_req = unpack_right_shift_u8(src_p[0], 0u, 0x03u);
    dst_p->adcu_crash_free = unpack_right_shift_u8(src_p[1], 6u, 0xc0u);
    dst_p->adcu_apv_pwr_off = unpack_right_shift_u8(src_p[1], 4u, 0x30u);
    dst_p->adcu_end_chg_req = unpack_right_shift_u8(src_p[1], 2u, 0x0cu);
    dst_p->adcu_wl_chg_wake_up_cmd = unpack_right_shift_u8(src_p[4], 0u, 0x01u);
    dst_p->adcu_pwr_cmd_roll_cnt = unpack_right_shift_u8(src_p[6], 0u, 0x0fu);
    dst_p->adcu_pwr_cmd_checksum = unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int psa_can_adcu_power_cmd_init(struct psa_can_adcu_power_cmd_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_adcu_power_cmd_t));

    return 0;
}

double psa_can_adcu_power_cmd_adcu_veh_pwrup_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_veh_pwrup_cmd_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_power_cmd_adcu_emg_brk_req_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_emg_brk_req_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_power_cmd_adcu_soft_emg_brk_req_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_soft_emg_brk_req_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_power_cmd_adcu_rmt_pwr_on_req_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_rmt_pwr_on_req_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_power_cmd_adcu_crash_free_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_crash_free_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_power_cmd_adcu_apv_pwr_off_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_apv_pwr_off_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_power_cmd_adcu_end_chg_req_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_end_chg_req_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

double psa_can_adcu_power_cmd_adcu_wl_chg_wake_up_cmd_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_wl_chg_wake_up_cmd_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

double psa_can_adcu_power_cmd_adcu_pwr_cmd_roll_cnt_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_pwr_cmd_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

double psa_can_adcu_power_cmd_adcu_pwr_cmd_checksum_decode(uint8_t value)
{
    return ((double)value);
}

bool psa_can_adcu_power_cmd_adcu_pwr_cmd_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_vcu_sweep_status1_pack(
    uint8_t *dst_p,
    const struct psa_can_vcu_sweep_status1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_dustbin_full_st, 7u, 0x80u);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_remain_water, 0u, 0x7fu);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_side_brush_extend_pos_st, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_side_brush_lift_pos_st, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_main_brush_pos_st, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_high_pump_angle_st, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->vcu_wash_probe_adjust_st, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_sweep_status2_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->vcu_sweep_status2_check_sum, 0u, 0xffu);

    return (8);
}

int psa_can_vcu_sweep_status1_init(struct psa_can_vcu_sweep_status1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_vcu_sweep_status1_t));

    return 0;
}

uint8_t psa_can_vcu_sweep_status1_vcu_dustbin_full_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status1_vcu_dustbin_full_st_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_sweep_status1_vcu_remain_water_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status1_vcu_remain_water_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

uint8_t psa_can_vcu_sweep_status1_vcu_side_brush_extend_pos_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status1_vcu_side_brush_extend_pos_st_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_sweep_status1_vcu_side_brush_lift_pos_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status1_vcu_side_brush_lift_pos_st_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_sweep_status1_vcu_main_brush_pos_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status1_vcu_main_brush_pos_st_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_sweep_status1_vcu_high_pump_angle_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status1_vcu_high_pump_angle_st_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_sweep_status1_vcu_wash_probe_adjust_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status1_vcu_wash_probe_adjust_st_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_sweep_status1_vcu_sweep_status2_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status1_vcu_sweep_status2_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_vcu_sweep_status1_vcu_sweep_status2_check_sum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status1_vcu_sweep_status2_check_sum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_vcu_sweep_status_pack(
    uint8_t *dst_p,
    const struct psa_can_vcu_sweep_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_fender_sts, 6u, 0xc0u);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_water_pump_sts, 4u, 0x30u);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_one_clk_dump_sts, 2u, 0x0cu);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_one_clk_clean_sts, 0u, 0x03u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_sweeping_sts, 6u, 0xc0u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_water_add_sts, 2u, 0x0cu);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_vbr_sts, 0u, 0x03u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_dust_bin_lift_sts, 6u, 0xc0u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_main_brush_lift_sts, 4u, 0x30u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_side_brush_extend_sts, 2u, 0x0cu);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_side_brush_lift_sts, 0u, 0x03u);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_side_brush_sts, 6u, 0xc0u);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_main_brush_sts, 4u, 0x30u);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_dust_bin_open_sts, 2u, 0x0cu);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_dust_bin_dump_sts, 0u, 0x03u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_dust_bin_compress_sts, 6u, 0xc0u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_vacuum_sts, 4u, 0x30u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_high_water_pump_sts, 2u, 0x0cu);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_blower_sts, 0u, 0x03u);
    dst_p[5] |= pack_left_shift_u8(src_p->vcu_wash_probe_adjust_sts, 6u, 0xc0u);
    dst_p[5] |= pack_left_shift_u8(src_p->vcu_high_pump_adjust_sts, 4u, 0x30u);
    dst_p[5] |= pack_left_shift_u8(src_p->vcu_wash_vale_sts, 2u, 0x0cu);
    dst_p[5] |= pack_left_shift_u8(src_p->vcu_clean_vale_sts, 0u, 0x03u);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_sweeper_sts_roll_cnt, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->vcu_sweeper_sts_check_sum, 0u, 0xffu);

    return (8);
}

int psa_can_vcu_sweep_status_init(struct psa_can_vcu_sweep_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_vcu_sweep_status_t));

    return 0;
}

uint8_t psa_can_vcu_sweep_status_vcu_fender_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_fender_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_water_pump_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_water_pump_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_one_clk_dump_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_one_clk_dump_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_one_clk_clean_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_one_clk_clean_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_sweeping_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_sweeping_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_water_add_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_water_add_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_sweep_status_vcu_vbr_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_vbr_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_dust_bin_lift_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_dust_bin_lift_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_main_brush_lift_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_main_brush_lift_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_side_brush_extend_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_side_brush_extend_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_side_brush_lift_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_side_brush_lift_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_side_brush_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_side_brush_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_main_brush_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_main_brush_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_dust_bin_open_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_dust_bin_open_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_dust_bin_dump_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_dust_bin_dump_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_dust_bin_compress_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_dust_bin_compress_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_vacuum_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_vacuum_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_high_water_pump_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_high_water_pump_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_blower_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_blower_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_wash_probe_adjust_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_wash_probe_adjust_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_high_pump_adjust_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_high_pump_adjust_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_wash_vale_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_wash_vale_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_clean_vale_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_clean_vale_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_sweep_status_vcu_sweeper_sts_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_sweeper_sts_roll_cnt_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_sweep_status_vcu_sweeper_sts_check_sum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_sweep_status_vcu_sweeper_sts_check_sum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_vcu_power_sts_pack(
    uint8_t *dst_p,
    const struct psa_can_vcu_power_sts_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_veh_pwrup_sts, 6u, 0xc0u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_wl_chg_wake_up_sts, 0u, 0x01u);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_pwr_cmd_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->vcu_pwr_cmd_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_vcu_power_sts_init(struct psa_can_vcu_power_sts_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_vcu_power_sts_t));

    return 0;
}

uint8_t psa_can_vcu_power_sts_vcu_veh_pwrup_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_power_sts_vcu_veh_pwrup_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_power_sts_vcu_wl_chg_wake_up_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_power_sts_vcu_wl_chg_wake_up_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_power_sts_vcu_pwr_cmd_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_power_sts_vcu_pwr_cmd_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_vcu_power_sts_vcu_pwr_cmd_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_power_sts_vcu_pwr_cmd_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_vcu_lamp_status_pack(
    uint8_t *dst_p,
    const struct psa_can_vcu_lamp_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[1] |= pack_left_shift_u8(src_p->vcu_head_lamp_sts, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_dbl_flash_lamp_sts, 6u, 0x40u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_turn_l_lamp_sts, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_turn_r_lamp_sts, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_reverse_lamp_sts, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_buzzer_sts, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_horn_sts, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_warning_lamp_sts, 0u, 0x01u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_brake_lamp_sts, 7u, 0x80u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_fog_lamp_sts, 6u, 0x40u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_width_lamp_sts, 5u, 0x20u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_wiper_sts, 4u, 0x10u);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_lamp_status_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->vcu_lamp_status_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_vcu_lamp_status_init(struct psa_can_vcu_lamp_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_vcu_lamp_status_t));

    return 0;
}

uint8_t psa_can_vcu_lamp_status_vcu_head_lamp_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_head_lamp_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_dbl_flash_lamp_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_dbl_flash_lamp_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_turn_l_lamp_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_turn_l_lamp_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_turn_r_lamp_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_turn_r_lamp_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_reverse_lamp_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_reverse_lamp_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_buzzer_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_buzzer_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_horn_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_horn_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_warning_lamp_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_warning_lamp_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_brake_lamp_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_brake_lamp_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_fog_lamp_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_fog_lamp_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_width_lamp_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_width_lamp_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_wiper_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_wiper_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_lamp_status_vcu_lamp_status_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_lamp_status_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_vcu_lamp_status_vcu_lamp_status_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_lamp_status_vcu_lamp_status_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_vcu_drive_status_pack(
    uint8_t *dst_p,
    const struct psa_can_vcu_drive_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_drving_mode, 5u, 0xe0u);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_drv_ctrl_mode, 2u, 0x0cu);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_drv_gear, 0u, 0x03u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_drv_act_pedpos, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->vcu_drv_act_veh_spd, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->vcu_drv_act_veh_spd, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_drv_act_veh_acc, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->vcu_drv_veh_spd_limit, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_drv_status_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->vcu_drv_status_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_vcu_drive_status_init(struct psa_can_vcu_drive_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_vcu_drive_status_t));

    return 0;
}

uint8_t psa_can_vcu_drive_status_vcu_drving_mode_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_drive_status_vcu_drving_mode_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t psa_can_vcu_drive_status_vcu_drv_ctrl_mode_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_drive_status_vcu_drv_ctrl_mode_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_drive_status_vcu_drv_gear_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_drive_status_vcu_drv_gear_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_drive_status_vcu_drv_act_pedpos_encode(double value)
{
    return (uint8_t)(value - -100.0);
}

bool psa_can_vcu_drive_status_vcu_drv_act_pedpos_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t psa_can_vcu_drive_status_vcu_drv_act_veh_spd_encode(double value)
{
    return (uint16_t)((value - -100.0) / 0.01);
}

bool psa_can_vcu_drive_status_vcu_drv_act_veh_spd_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_drive_status_vcu_drv_act_veh_acc_encode(double value)
{
    return (uint8_t)((value - -15.0) / 0.1);
}

bool psa_can_vcu_drive_status_vcu_drv_act_veh_acc_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_drive_status_vcu_drv_veh_spd_limit_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

bool psa_can_vcu_drive_status_vcu_drv_veh_spd_limit_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_drive_status_vcu_drv_status_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_drive_status_vcu_drv_status_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_vcu_drive_status_vcu_drv_status_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_drive_status_vcu_drv_status_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_vcu_steer_status_pack(
    uint8_t *dst_p,
    const struct psa_can_vcu_steer_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_str_work_mode, 7u, 0x80u);
    dst_p[1] |= pack_right_shift_u16(src_p->vcu_str_angle, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->vcu_str_angle, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_str_angle_spd, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->vcu_str_centering_sts, 0u, 0x01u);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_str_status_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->vcu_str_status_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_vcu_steer_status_init(struct psa_can_vcu_steer_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_vcu_steer_status_t));

    return 0;
}

uint8_t psa_can_vcu_steer_status_vcu_str_work_mode_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_steer_status_vcu_str_work_mode_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t psa_can_vcu_steer_status_vcu_str_angle_encode(double value)
{
    return (uint16_t)((value - -90.0) / 0.005);
}

bool psa_can_vcu_steer_status_vcu_str_angle_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_steer_status_vcu_str_angle_spd_encode(double value)
{
    return (uint8_t)(value / 0.2);
}

bool psa_can_vcu_steer_status_vcu_str_angle_spd_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_steer_status_vcu_str_centering_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_steer_status_vcu_str_centering_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_steer_status_vcu_str_status_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_steer_status_vcu_str_status_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_vcu_steer_status_vcu_str_status_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_steer_status_vcu_str_status_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_vcu_brake_status_pack(
    uint8_t *dst_p,
    const struct psa_can_vcu_brake_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_brk_ctrl_mode_sts, 6u, 0xc0u);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_brk_park_enable_sts, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_brk_act_pedpos, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->vcu_brk_act_press, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->vcu_brk_act_press, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->vcu_brk_acc, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->vcu_brk_acc, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_brk_status_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->vcu_brk_status_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_vcu_brake_status_init(struct psa_can_vcu_brake_status_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_vcu_brake_status_t));

    return 0;
}

uint8_t psa_can_vcu_brake_status_vcu_brk_ctrl_mode_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_brake_status_vcu_brk_ctrl_mode_sts_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_brake_status_vcu_brk_park_enable_sts_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_brake_status_vcu_brk_park_enable_sts_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_brake_status_vcu_brk_act_pedpos_encode(double value)
{
    return (uint8_t)(value / 0.4);
}

bool psa_can_vcu_brake_status_vcu_brk_act_pedpos_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t psa_can_vcu_brake_status_vcu_brk_act_press_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

bool psa_can_vcu_brake_status_vcu_brk_act_press_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t psa_can_vcu_brake_status_vcu_brk_acc_encode(double value)
{
    return (uint16_t)((value - -20.0) / 0.01);
}

bool psa_can_vcu_brake_status_vcu_brk_acc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_brake_status_vcu_brk_status_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_brake_status_vcu_brk_status_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_vcu_brake_status_vcu_brk_status_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_brake_status_vcu_brk_status_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_vcu_info_pack(
    uint8_t *dst_p,
    const struct psa_can_vcu_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_software_ver_num, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_hardware_ver_num, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_bat_soc, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_remain_water, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_remain_trash_bin, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_info_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->vcu_info_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_vcu_info_init(struct psa_can_vcu_info_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_vcu_info_t));

    return 0;
}

uint8_t psa_can_vcu_info_vcu_software_ver_num_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_info_vcu_software_ver_num_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_info_vcu_hardware_ver_num_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_info_vcu_hardware_ver_num_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_info_vcu_bat_soc_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_info_vcu_bat_soc_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_info_vcu_remain_water_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_info_vcu_remain_water_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_info_vcu_remain_trash_bin_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_info_vcu_remain_trash_bin_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_info_vcu_info_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_info_vcu_info_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_info_vcu_info_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_info_vcu_info_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int psa_can_vcu_veh_state_pack(
    uint8_t *dst_p,
    const struct psa_can_vcu_veh_state_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->vcu_veh_run_mode, 4u, 0xf0u);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_veh_run_lock_rsn, 2u, 0x0cu);
    dst_p[0] |= pack_left_shift_u8(src_p->vcu_veh_err_level, 0u, 0x03u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_ft_crash_st, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_rr_crash_st, 6u, 0x40u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_veh_emgcy_swh_st, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_lv_bat_low_volt, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_bat_low_soc, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->vcu_bms_err_level, 1u, 0x06u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_mcu_err_level, 6u, 0xc0u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_ehb_err_level, 4u, 0x30u);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_eps_err_level, 2u, 0x0cu);
    dst_p[2] |= pack_left_shift_u8(src_p->vcu_epb_err_level, 0u, 0x03u);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_ccu_err_level, 6u, 0xc0u);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_dump_sys_err_lvl, 4u, 0x30u);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_clean_sys_err_lvl, 2u, 0x0cu);
    dst_p[3] |= pack_left_shift_u8(src_p->vcu_can_bus_off_st, 0u, 0x03u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_seg_code_disp_offline_err, 7u, 0x80u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_led_disp_offline_err, 6u, 0x40u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_chg_inhibit_flt, 5u, 0x20u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_pwr_up_inhibit_flt, 4u, 0x10u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_ad_emgcy_stop_st, 3u, 0x08u);
    dst_p[4] |= pack_left_shift_u8(src_p->vcu_veh_emgcy_stop_reason, 0u, 0x07u);
    dst_p[5] |= pack_left_shift_u8(src_p->vcu_veh_err_code, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_rcu_err_level, 6u, 0xc0u);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_pmu_err_level, 4u, 0x30u);
    dst_p[6] |= pack_left_shift_u8(src_p->vcu_veh_st_roll_cnt, 0u, 0x0fu);
    dst_p[7] |= pack_left_shift_u8(src_p->vcu_veh_st_checksum, 0u, 0xffu);

    return (8);
}

int psa_can_vcu_veh_state_init(struct psa_can_vcu_veh_state_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct psa_can_vcu_veh_state_t));

    return 0;
}

uint8_t psa_can_vcu_veh_state_vcu_veh_run_mode_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_veh_run_mode_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_vcu_veh_state_vcu_veh_run_lock_rsn_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_veh_run_lock_rsn_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_veh_err_level_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_veh_err_level_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_ft_crash_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_ft_crash_st_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_rr_crash_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_rr_crash_st_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_veh_emgcy_swh_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_veh_emgcy_swh_st_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_lv_bat_low_volt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_lv_bat_low_volt_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_bat_low_soc_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_bat_low_soc_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_bms_err_level_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_bms_err_level_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_mcu_err_level_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_mcu_err_level_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_ehb_err_level_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_ehb_err_level_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_eps_err_level_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_eps_err_level_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_epb_err_level_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_epb_err_level_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_ccu_err_level_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_ccu_err_level_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_dump_sys_err_lvl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_dump_sys_err_lvl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_clean_sys_err_lvl_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_clean_sys_err_lvl_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_can_bus_off_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_can_bus_off_st_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_seg_code_disp_offline_err_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_seg_code_disp_offline_err_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_led_disp_offline_err_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_led_disp_offline_err_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_chg_inhibit_flt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_chg_inhibit_flt_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_pwr_up_inhibit_flt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_pwr_up_inhibit_flt_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_ad_emgcy_stop_st_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_ad_emgcy_stop_st_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t psa_can_vcu_veh_state_vcu_veh_emgcy_stop_reason_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_veh_emgcy_stop_reason_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t psa_can_vcu_veh_state_vcu_veh_err_code_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_veh_err_code_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t psa_can_vcu_veh_state_vcu_rcu_err_level_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_rcu_err_level_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_pmu_err_level_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_pmu_err_level_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t psa_can_vcu_veh_state_vcu_veh_st_roll_cnt_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_veh_st_roll_cnt_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t psa_can_vcu_veh_state_vcu_veh_st_checksum_encode(double value)
{
    return (uint8_t)(value);
}

bool psa_can_vcu_veh_state_vcu_veh_st_checksum_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}
